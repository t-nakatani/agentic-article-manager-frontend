
## コードの変更や機能追加について
目的Aを達成するための修正で、別の目的Bを同時に修正しないでください。

ロジックの追加や変更の前後で、見た目(UI)変更が起こらないよう最大限の注意を払ってください。

見た目(UI)の変更時に、ロジックの変更が起こらないよう最大限の注意を払ってください。



## 設計・コードについて

### SOLID原則
SOLID原則、特に開放閉鎖の原則と単一責務の原則を意識ししてください。

#### 単一責務の原則
単一責務の原則は、複数の責務を持つ大きなモジュールを責務分離により小さく保つために重要です。

#### 開放閉鎖の原則
開放閉鎖の原則は、新しい機能を追加する際に既存のコードを変更しないで済むようにするために重要です。
同じような要素の拡張が想定される場合には、適切に抽象化してください。

### モジュール化
モジュール化を意識してください。
モジュールを作成する際は、そのモジュールが変更・削除されても他のモジュールに影響が及ばない設計を意識してください。

## 開発の阻害要因
LLMによるコード生成の肝は速さです。それが故にたくさん書いてたくさん捨てることができます。この特性を最大限活用するには、機能の追加時と削除時にバグを起こさないようにする必要があります。
これを妨げる支配的な場面は、「大きなコードブロックを丸々置き換える」場面です。


## 対策
1つは、plugableな設計を意識することです。
plugableとは簡単に差し替え・拡張可能なコードを指します。ユーザというインターフェイスさえ守っていれば、ログインユーザをログアウトユーザに転用できるような場合、plugableです。
簡単に置換できることは、LLMによるコード全体の書き換えが発生しづらいことを意味します。

もう1つはコンポーザビリティです。
小さな部品がお互いを必要とせず、独立して動くアプリケーションはコンポーザビリティを有すると言えます。責務が明確でお互いに疎結合であれば、部品となるモジュールを追加・削除する際に変更位置は明確であり小さくなるはずです。

### 状態管理について
Reduxを利用してください。

## プロジェクトについて
APIは外部のものを利用しています
- articles
- themes
- feedback
- files

## Markdown Formatting
* If there are code snippets, display the code as plaintext in markdown and do not add any additional formatting such as backticks or indents  
* DO NOT ADD ANY FORMATTING INCLUDING BACKTICKS WITH THE EXCEPTION OF INDENTS INSIDE THE MARKDOWN


## Next

### 技術スタック

このプロジェクトでは、以下の技術スタックとその公式ドキュメントを使用する。

- Next.js App Router（ルーティングとデータ取得）  
  https://nextjs.org/docs/app

- TailwindCSS（ユーティリティベースのスタイル設計）  
  https://tailwindcss.com/docs

- shadcn/ui（UI コンポーネントライブラリ）  
  https://ui.shadcn.com/docs

- Framer Motion（アニメーションとトランジション）  
  https://www.framer.com/motion/

### コーディングスタイル

#### ファイル構成と責務分離

- 各コンポーネントは単一責任を持つ。
- ロジックは hooks/ に、共通処理は utils/ に配置する。
- API 処理や外部連携は lib/ に切り出す。
- ディレクトリは関数単位・機能単位で整理する。

#### ファイル内の構成順

1. エクスポートされたコンポーネント
2. サブコンポーネント
3. ヘルパー関数
4. 静的データ
5. 型定義

### 命名規則

- ディレクトリ名はケバブケース（例：components/auth-form）
- コンポーネント名、型名は PascalCase
- 関数名、変数名、React フックはキャメルケース
- カスタムフックには use をプレフィックスとして付ける（例：useUser）

- コンポーネントは名前付きエクスポートを使用し、default export は避ける

### TypeScript の使い方

- オブジェクト構造の定義には interface を使用する
- プリミティブ型やユニオン型には type を使用する
- Props の型定義には interface を使用する
- 再利用可能な処理にはジェネリック型を使用する（例：function useFetch<T>()）

### コメント方針

- 自明なコードに過剰なコメントを付けない
- 意図が伝わりにくい処理にはコメントを付ける
- コンポーネントの冒頭などにはブロックコメントを用いる

例：
// ユーザー情報を表示するコンポーネント

### UI 実装とスタイリング

- UI 実装には TailwindCSS, shadcn/ui, Radix UI を使用する
- カスタマイズは className と cn() 関数で行う
- スタイリングは Tailwind のユーティリティクラスを使用し、生の CSS は避ける
- レスポンシブ対応はモバイルファーストの方針とする
- Framer Motion は必要最小限の用途に絞って使用する

### パフォーマンス最適化

- React Server Components（RSC）を優先して使用する
- "use client" の使用は必要最小限とし、状態管理や副作用の用途に限定する
- クライアントコンポーネントは Suspense でラップし、フォールバックを設ける
- 不要な再レンダリングを防ぐため、useMemo / useCallback を適切に使用する
- dynamic() を使用して、モーダルやチャートなど重要でない UI を遅延読み込みする
- 画像は next/image を使用し、WebP形式、width/height指定、遅延読み込みを行う
- URL 検索パラメータの管理には nuqs を使用する

### Web Vitals 最適化

- LCP / CLS / FID を意識し、UX の品質を担保する
- レンダリング戦略は以下から適切に選定する：
  - SSR（サーバーサイドレンダリング）
  - ISR（増分静的再生成）
  - SSG（静的サイト生成）

### アクセシビリティ

- aria-* 属性を適切に設定し、キーボード操作・フォーカス制御を考慮する
- ラベル・役割・状態などを明示する

### ベストプラクティス

- default export を避け、名前付きエクスポートを徹底する
- 技術選定の理由を説明できる状態にしておく
- コンポーネントやロジックの責任を明確に保つ
- 公式ドキュメントのベストプラクティスに準拠する